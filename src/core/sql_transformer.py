import re


class SQLTransformer:
    """
    Structural SQL normalization layer.

    Responsibilities:
    - Enforce engine-wide structural policies (e.g., no EXISTS / NOT EXISTS)
    - Apply controlled heuristic rewrites (e.g., NOT EXISTS → LEFT JOIN anti-join)
    - Perform lightweight structural normalization before execution

    IMPORTANT:
    This module is NOT a full SQL parser.
    It handles only known and controlled patterns generated by the LLM.
    Complex correlated subqueries may not be safely rewritten.
    """

    @staticmethod
    def rewrite_structural(sql: str) -> str:
        if not sql:
            return sql

        sql = SQLTransformer._rewrite_not_exists(sql)
        sql = SQLTransformer._strip_exists(sql)
        sql = SQLTransformer._enforce_distinct_on_antijoin(sql)

        return sql.strip()

    # ============================================================
    # Rewrite NOT EXISTS → LEFT JOIN anti-join
    # ============================================================

    @staticmethod
    def _rewrite_not_exists(sql: str) -> str:
        lowered = sql.lower()

        if "not exists" not in lowered:
            return sql

        # Handles pattern:
        # WHERE NOT EXISTS (
        #     SELECT 1 FROM table alias
        #     WHERE alias.col = outer.col
        #       AND ...
        # )
        pattern = re.compile(
            r"""
            where\s+not\s+exists\s*\(
                \s*select\s+1\s+from\s+
                (?P<table>[a-zA-Z_][a-zA-Z0-9_]*)\s+
                (?P<alias>[a-zA-Z_][a-zA-Z0-9_]*)\s+
                where\s+(?P<conditions>.+?)
            \)
            """,
            re.IGNORECASE | re.DOTALL | re.VERBOSE,
        )

        match = pattern.search(sql)

        if not match:
            return sql

        table = match.group("table")
        alias = match.group("alias")
        conditions = match.group("conditions").strip()

        # Remove original NOT EXISTS block
        sql_without = pattern.sub("", sql)

        # Build LEFT JOIN
        join_clause = f" LEFT JOIN {table} {alias} ON {conditions} "

        # Inject join before first WHERE
        where_match = re.search(r"\bwhere\b", sql_without, re.IGNORECASE)

        if where_match:
            idx = where_match.start()
            before = sql_without[:idx]
            after = sql_without[idx:]
            rewritten = (
                before
                + join_clause
                + after
                + f" AND {alias}.rowid IS NULL"
            )
        else:
            rewritten = (
                sql_without
                + join_clause
                + f" WHERE {alias}.rowid IS NULL"
            )

        return rewritten

    # ============================================================
    # Hard policy: strip remaining EXISTS if any survive
    # ============================================================

    @staticmethod
    def _strip_exists(sql: str) -> str:
        """
        If EXISTS survives pattern rewrite,
        remove it defensively to avoid engine policy violation.
        """

        sql = re.sub(
            r"\bexists\s*\([^)]*\)",
            "",
            sql,
            flags=re.IGNORECASE | re.DOTALL,
        )

        return sql

    # ============================================================
    # Anti-join safety: enforce DISTINCT when using LEFT JOIN ... IS NULL
    # ============================================================

    @staticmethod
    def _enforce_distinct_on_antijoin(sql: str) -> str:
        """
        If query uses LEFT JOIN + IS NULL anti-join
        and does not contain DISTINCT or GROUP BY,
        enforce SELECT DISTINCT to avoid duplicate rows.
        """

        lowered = sql.lower()

        # Detect anti-join pattern
        if "left join" in lowered and "is null" in lowered:
            has_group_by = "group by" in lowered
            has_distinct = "select distinct" in lowered

            if not has_group_by and not has_distinct:
                # Inject DISTINCT right after SELECT
                sql = re.sub(
                    r"^\s*select\s+",
                    "SELECT DISTINCT ",
                    sql,
                    flags=re.IGNORECASE,
                )

        return sql